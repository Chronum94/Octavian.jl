var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CurrentModule = Octavian","category":"page"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Multi-threaded-matrix-multiplication:-matmul!-and-matmul","page":"Getting Started","title":"Multi-threaded matrix multiplication: matmul! and matmul","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Remember to start Julia with multiple threads with e.g. one of the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia -t auto\njulia -t 4\nSet the JULIA_NUM_THREADS environment variable to 4 before starting Julia","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Octavian\n\nA = [1 2 3; 4 5 6]\n\nB = [7 8 9 10; 11 12 13 14; 15 16 17 18]\n\nC = Matrix{Int}(undef, 2, 4)\n\nOctavian.matmul!(C, A, B) # (multi-threaded) multiply A×B and store the result in C (overwriting the contents of C)\n\nC\n\nC == A * B","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Octavian\n\nA = [1 2 3; 4 5 6]\n\nB = [7 8 9 10; 11 12 13 14; 15 16 17 18]\n\nC = Octavian.matmul(A, B)  # (multi-threaded) multiply A×B and return the result\n\nC\n\nC == A * B","category":"page"},{"location":"public-api/","page":"Public API","title":"Public API","text":"CurrentModule = Octavian","category":"page"},{"location":"public-api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public-api/","page":"Public API","title":"Public API","text":"Modules = [Octavian]\nPages   = [\"public-api.md\"]","category":"page"},{"location":"public-api/","page":"Public API","title":"Public API","text":"Modules = [Octavian]\nPublic = true\nPrivate = false","category":"page"},{"location":"public-api/#Octavian.matmul!-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,2}}, Tuple{AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,2},Any}, Tuple{AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,2},Any,Any}} where T","page":"Public API","title":"Octavian.matmul!","text":"matmul!(C::AbstractMatrix, A::AbstractMatrix, B::AbstractMatrix, _α = 1, _β = 0)\n\n\n\n\n\n","category":"method"},{"location":"public-api/#Octavian.matmul-Union{Tuple{Tb}, Tuple{Ta}, Tuple{AbstractArray{Ta,2},AbstractArray{Tb,2}}} where Tb where Ta","page":"Public API","title":"Octavian.matmul","text":"matmul(A::AbstractMatrix, B::AbstractMatrix)\n\nReturn the matrix product A*B.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Octavian","category":"page"},{"location":"#Octavian","page":"Home","title":"Octavian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Octavian.jl is a multi-threaded BLAS-like library that provides pure Julia matrix multiplication, built on top of LoopVectorization.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The source code for Octavian is available in the GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may also be interested in:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tullio.jl\nGaius.jl\nPaddedMatrices.jl","category":"page"},{"location":"internals/","page":"Internals (Private)","title":"Internals (Private)","text":"CurrentModule = Octavian","category":"page"},{"location":"internals/#Internals-(Private)","page":"Internals (Private)","title":"Internals (Private)","text":"","category":"section"},{"location":"internals/","page":"Internals (Private)","title":"Internals (Private)","text":"Modules = [Octavian]\nPages   = [\"internals.md\"]","category":"page"},{"location":"internals/","page":"Internals (Private)","title":"Internals (Private)","text":"Modules = [Octavian]\nPublic = false\nPrivate = true","category":"page"},{"location":"internals/#Octavian.block_sizes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals (Private)","title":"Octavian.block_sizes","text":"block_sizes(::Type{T}) -> (Mc, Kc, Nc)\n\nReturns the dimensions of our macrokernel, which iterates over the microkernel. That is, in calculating C = A * B, our macrokernel will be called on Mc × Kc blocks of A, multiplying  them with Kc × Nc blocks of B, to update Mc × Nc blocks of C.\n\nWe want these blocks to fit nicely in the cache. There is a lot of room for improvement here, but this initial implementation should work reasonably well.\n\nThe constants LoopVectorization.mᵣ and LoopVectorization.nᵣ are the factors by which LoopVectorization wants to unroll the rows and columns of the microkernel, respectively. LoopVectorization defines these constants by running it's analysis on a gemm kernel; they're there for convenience/to make it easier to implement matrix-multiply. It also wants to vectorize the rows by W = VectorizationBase.pick_vector_width_val(T). Thus, the microkernel's dimensions are (W * mᵣ) × nᵣ; that is, the microkernel updates a (W * mᵣ) × nᵣ block of C.\n\nBecause the macrokernel iterates over tiles and repeatedly applies the microkernel, we would prefer the macrokernel's dimensions to be an integer multiple of the microkernel's. That is, we want Mc to be an integer multiple of W * mᵣ and Nc to be an integer multiple of nᵣ.\n\nAdditionally, we want our blocks of A to fit in the core-local L2 cache. Empirically, I found that when using Float64 arrays, 72 rows works well on Haswell (where W * mᵣ = 8) and 96 works well for Cascadelake (where W * mᵣ = 24). So I kind of heuristically multiply W * mᵣ by 4 given 32 vector register (as in Cascadelake), which would yield 96, and multiply by 9 otherwise, which would give 72 on Haswell. Ideally, we'd have a better means of picking. I suspect relatively small numbers work well because I'm currently using a column-major memory layout for the internal packing arrays. A column-major memory layout means that if our macro-kernel had a lot of rows, moving across columns would involve reading memory far apart, moving across memory pages more rapidly, hitting the TLB harder. This is why libraries like OpenBLAS and BLIS don't use a column-major layout, but reshape into a 3-d array, e.g. A will be reshaped into a Mᵣ × Kc × (Mc ÷ Mᵣ) array (also sometimes referred to as a tile-major matrix), so that all memory reads happen in consecutive memory locations.\n\nNow that we have Mc, we use it and the L2 cache size to calculate Kc, but shave off a percent to leave room in the cache for some other things.\n\nWe want out blocks of B to fir in the L3 cache, so we can use the L3 cache-size and Kc to similarly calculate Nc, with the additional note that we also divide and multiply by nᵣ to ensure that Nc is an integer multiple of nᵣ.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Octavian.macrokernel!-NTuple{5,Any}","page":"Internals (Private)","title":"Octavian.macrokernel!","text":"The macrokernel. It iterates over our tiles, and applies the microkernel.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Octavian.matmul_sizes-Tuple{Any,Any,Any}","page":"Internals (Private)","title":"Octavian.matmul_sizes","text":"Checks sizes for compatibility, and preserves the static size information if given a mix of static and dynamic sizes.\n\n\n\n\n\n","category":"method"}]
}
