<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Octavian.jl</title><link rel="canonical" href="https://JuliaLinearAlgebra.github.io/Octavian.jl/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Octavian.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLinearAlgebra/Octavian.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#Octavian.block_sizes-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Octavian.block_sizes</code></a></li><li><a href="#Octavian.macrokernel!-NTuple{5,Any}"><code>Octavian.macrokernel!</code></a></li><li><a href="#Octavian.matmul_sizes-Tuple{Any,Any,Any}"><code>Octavian.matmul_sizes</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Octavian.block_sizes-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Octavian.block_sizes-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Octavian.block_sizes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>block_sizes(::Type{T}) -&gt; (Mc, Kc, Nc)</p><p>Returns the dimensions of our macrokernel, which iterates over the microkernel. That is, in calculating <code>C = A * B</code>, our macrokernel will be called on <code>Mc × Kc</code> blocks of <code>A</code>, multiplying  them with <code>Kc × Nc</code> blocks of <code>B</code>, to update <code>Mc × Nc</code> blocks of <code>C</code>.</p><p>We want these blocks to fit nicely in the cache. There is a lot of room for improvement here, but this initial implementation should work reasonably well.</p><p>The constants <code>LoopVectorization.mᵣ</code> and <code>LoopVectorization.nᵣ</code> are the factors by which LoopVectorization wants to unroll the rows and columns of the microkernel, respectively. <code>LoopVectorization</code> defines these constants by running it&#39;s analysis on a gemm kernel; they&#39;re there for convenience/to make it easier to implement matrix-multiply. It also wants to vectorize the rows by <code>W = VectorizationBase.pick_vector_width_val(T)</code>. Thus, the microkernel&#39;s dimensions are <code>(W * mᵣ) × nᵣ</code>; that is, the microkernel updates a <code>(W * mᵣ) × nᵣ</code> block of <code>C</code>.</p><p>Because the macrokernel iterates over tiles and repeatedly applies the microkernel, we would prefer the macrokernel&#39;s dimensions to be an integer multiple of the microkernel&#39;s. That is, we want <code>Mc</code> to be an integer multiple of <code>W * mᵣ</code> and <code>Nc</code> to be an integer multiple of <code>nᵣ</code>.</p><p>Additionally, we want our blocks of <code>A</code> to fit in the core-local L2 cache. Empirically, I found that when using <code>Float64</code> arrays, 72 rows works well on Haswell (where <code>W * mᵣ = 8</code>) and 96 works well for Cascadelake (where <code>W * mᵣ = 24</code>). So I kind of heuristically multiply <code>W * mᵣ</code> by <code>4</code> given 32 vector register (as in Cascadelake), which would yield <code>96</code>, and multiply by <code>9</code> otherwise, which would give <code>72</code> on Haswell. Ideally, we&#39;d have a better means of picking. I suspect relatively small numbers work well because I&#39;m currently using a column-major memory layout for the internal packing arrays. A column-major memory layout means that if our macro-kernel had a lot of rows, moving across columns would involve reading memory far apart, moving across memory pages more rapidly, hitting the TLB harder. This is why libraries like OpenBLAS and BLIS don&#39;t use a column-major layout, but reshape into a 3-d array, e.g. <code>A</code> will be reshaped into a <code>Mᵣ × Kc × (Mc ÷ Mᵣ)</code> array (also sometimes referred to as a tile-major matrix), so that all memory reads happen in consecutive memory locations.</p><p>Now that we have <code>Mc</code>, we use it and the <code>L2</code> cache size to calculate <code>Kc</code>, but shave off a percent to leave room in the cache for some other things.</p><p>We want out blocks of <code>B</code> to fir in the <code>L3</code> cache, so we can use the <code>L3</code> cache-size and <code>Kc</code> to similarly calculate <code>Nc</code>, with the additional note that we also divide and multiply by <code>nᵣ</code> to ensure that <code>Nc</code> is an integer multiple of <code>nᵣ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/Octavian.jl/blob/cf3b37af0c15e5fc79b28519146ba8271838c88f/src/block_sizes.jl#LL2-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Octavian.macrokernel!-NTuple{5,Any}" href="#Octavian.macrokernel!-NTuple{5,Any}"><code>Octavian.macrokernel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The macrokernel. It iterates over our tiles, and applies the microkernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/Octavian.jl/blob/cf3b37af0c15e5fc79b28519146ba8271838c88f/src/macrokernel.jl#LL2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Octavian.matmul_sizes-Tuple{Any,Any,Any}" href="#Octavian.matmul_sizes-Tuple{Any,Any,Any}"><code>Octavian.matmul_sizes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks sizes for compatibility, and preserves the static size information if given a mix of static and dynamic sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/Octavian.jl/blob/cf3b37af0c15e5fc79b28519146ba8271838c88f/src/utils.jl#LL8-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 28 December 2020 14:45">Monday 28 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
